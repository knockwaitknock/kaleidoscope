<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Live Camera Kaleidoscope</title>
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: #0b0b0f;
      color: #eaeaf2;
    }

    .canvas-wrap {
      position: relative;
      width: 100vw;
      height: 100dvh;
      overflow: hidden;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: radial-gradient(circle at 50% 50%, #1a1a22, #0b0b0f);
    }

    .floating-bar {
      position: absolute;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      z-index: 10;
    }
    .floating-bar button {
      backdrop-filter: blur(12px);
      background: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.18);
      color: #fff;
      border-radius: 14px;
      padding: 10px 18px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s;
    }
    .floating-bar button:hover { background: rgba(255,255,255,0.12); }
    .floating-bar button:disabled { opacity: 0.35; pointer-events: none; }

    .scroll-hint {
      position: absolute;
      bottom: 68px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 12px;
      opacity: 0.5;
      pointer-events: none;
      animation: pulse 2.5s ease-in-out infinite;
    }
    @keyframes pulse { 0%,100% { opacity: 0.3; } 50% { opacity: 0.7; } }

    .controls {
      max-width: 600px;
      margin: 0 auto;
      padding: 24px 16px 48px;
    }
    .controls h1 {
      font-size: 16px;
      margin: 0 0 16px;
      font-weight: 700;
      letter-spacing: 0.2px;
    }
    .group {
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 10px;
      margin-bottom: 10px;
      background: rgba(255,255,255,0.03);
    }
    .group h2 {
      font-size: 12px;
      margin: 0 0 8px;
      opacity: 0.9;
      font-weight: 650;
    }
    label {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
      font-size: 12px;
      margin: 8px 0;
      opacity: 0.95;
    }
    input[type="range"] { width: 100%; }
    input[type="number"] {
      width: 90px;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.12);
      color: inherit;
      border-radius: 8px;
      padding: 6px 8px;
    }
    button, select {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.14);
      color: inherit;
      border-radius: 10px;
      padding: 8px 10px;
      cursor: pointer;
    }
    button:hover { background: rgba(255,255,255,0.10); }
    .row { display: flex; gap: 8px; flex-wrap: wrap; }
    .note {
      font-size: 12px;
      opacity: 0.75;
      line-height: 1.35;
      margin-top: 8px;
    }
    video { display: none; }
  </style>
</head>
<body>

<div class="canvas-wrap">
  <canvas id="c"></canvas>
  <div class="scroll-hint">â†“ scroll for controls</div>
  <div class="floating-bar">
    <button id="btnStart">Start camera</button>
    <button id="btnStop" disabled>Stop</button>
    <button id="btnReset">Reset</button>
  </div>
</div>

<section class="controls">
  <h1>Controls</h1>

  <div class="group">
    <h2>Pattern</h2>

    <label>
      Segments
      <input id="segments" type="number" min="3" max="64" step="1" value="12" />
    </label>

    <label>
      Zoom
      <input id="zoom" type="range" min="0.5" max="3" step="0.01" value="1.25" />
    </label>

    <label>
      Rotation
      <input id="rotation" type="range" min="-180" max="180" step="0.1" value="0" />
    </label>

    <label>
      Mirror every other wedge
      <input id="mirror" type="checkbox" checked />
    </label>

    <label>
      Smoothing
      <input id="smooth" type="checkbox" checked />
    </label>

    <div class="note">
      Tip: fewer segments = faster. If it's laggy, lower segments or your browser's camera resolution.
    </div>
  </div>

  <div class="group">
    <h2>Center</h2>

    <label>
      Center X
      <input id="cx" type="range" min="0" max="1" step="0.001" value="0.5" />
    </label>

    <label>
      Center Y
      <input id="cy" type="range" min="0" max="1" step="0.001" value="0.5" />
    </label>

    <label>
      Radius
      <input id="radius" type="range" min="0.25" max="1.2" step="0.01" value="0.9" />
    </label>

    <div class="note">
      Center controls which part of the video you sample. Radius controls how much of the frame is used.
    </div>
  </div>

  <div class="group">
    <h2>Camera</h2>
    <label>
      Facing
      <select id="facing">
        <option value="user">Front (selfie)</option>
        <option value="environment" selected>Back</option>
      </select>
    </label>

    <label>
      Target width
      <input id="camW" type="number" min="160" max="1920" step="10" value="640" />
    </label>

    <label>
      Target height
      <input id="camH" type="number" min="120" max="1080" step="10" value="480" />
    </label>

    <div class="note">
      Camera constraints are "best effort". If permission fails, try different width/height or switch facing mode.
    </div>
  </div>
</section>

<video id="v" playsinline muted></video>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  const video = document.getElementById('v');

  const btnStart = document.getElementById('btnStart');
  const btnStop  = document.getElementById('btnStop');
  const btnReset = document.getElementById('btnReset');

  const elSegments = document.getElementById('segments');
  const elZoom = document.getElementById('zoom');
  const elRotation = document.getElementById('rotation');
  const elMirror = document.getElementById('mirror');
  const elSmooth = document.getElementById('smooth');

  const elCx = document.getElementById('cx');
  const elCy = document.getElementById('cy');
  const elRadius = document.getElementById('radius');

  const elFacing = document.getElementById('facing');
  const elCamW = document.getElementById('camW');
  const elCamH = document.getElementById('camH');

  const src = document.createElement('canvas');
  const sctx = src.getContext('2d');

  let stream = null;
  let rafId = null;

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const w = Math.floor(canvas.clientWidth * dpr);
    const h = Math.floor(canvas.clientHeight * dpr);
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
    }
  }
  window.addEventListener('resize', resize, { passive: true });
  resize();

  async function startCamera() {
    stopCamera();

    const facingMode = elFacing.value;
    const targetW = parseInt(elCamW.value, 10) || 640;
    const targetH = parseInt(elCamH.value, 10) || 480;

    const constraints = {
      audio: false,
      video: {
        facingMode,
        width: { ideal: targetW },
        height: { ideal: targetH }
      }
    };

    try {
      stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;
      await video.play();

      src.width = video.videoWidth || targetW;
      src.height = video.videoHeight || targetH;

      btnStart.disabled = true;
      btnStop.disabled = false;

      render();
    } catch (err) {
      console.error(err);
      alert("Could not start camera. Make sure you're on https:// or localhost and allow permission.\n\n" + err.message);
    }
  }

  function stopCamera() {
    if (rafId) cancelAnimationFrame(rafId);
    rafId = null;

    if (video) {
      try { video.pause(); } catch {}
      video.srcObject = null;
    }

    if (stream) {
      stream.getTracks().forEach(t => t.stop());
      stream = null;
    }

    btnStart.disabled = false;
    btnStop.disabled = true;
  }

  function resetControls() {
    elSegments.value = 12;
    elZoom.value = 1.25;
    elRotation.value = 0;
    elMirror.checked = true;
    elSmooth.checked = true;

    elCx.value = 0.5;
    elCy.value = 0.5;
    elRadius.value = 0.9;

    elFacing.value = "environment";
    elCamW.value = 640;
    elCamH.value = 480;
  }

  function render() {
    resize();

    const W = canvas.width;
    const H = canvas.height;
    const cx = W * parseFloat(elCx.value);
    const cy = H * parseFloat(elCy.value);

    const segments = Math.max(3, Math.min(64, parseInt(elSegments.value, 10) || 12));
    const zoom = parseFloat(elZoom.value);
    const rot = (parseFloat(elRotation.value) * Math.PI) / 180;
    const mirror = !!elMirror.checked;

    const diag = Math.sqrt(W * W + H * H);
    const radius = diag * parseFloat(elRadius.value);

    if (video.readyState >= 2) {
      if (src.width !== video.videoWidth || src.height !== video.videoHeight) {
        src.width = video.videoWidth;
        src.height = video.videoHeight;
      }
      sctx.drawImage(video, 0, 0, src.width, src.height);
    }

    ctx.imageSmoothingEnabled = !!elSmooth.checked;

    ctx.setTransform(1, 0, 0, 1, 0, 0);

    // Fill background with the average color of the current camera frame
    if (src.width > 0 && src.height > 0) {
      const small = 8;
      sctx.save();
      sctx.drawImage(src, 0, 0, small, small);
      const d = sctx.getImageData(0, 0, small, small).data;
      let r = 0, g = 0, b = 0;
      const count = small * small;
      for (let p = 0; p < count; p++) {
        r += d[p * 4];
        g += d[p * 4 + 1];
        b += d[p * 4 + 2];
      }
      ctx.fillStyle = `rgb(${Math.round(r / count)},${Math.round(g / count)},${Math.round(b / count)})`;
      sctx.restore();
      sctx.drawImage(video, 0, 0, src.width, src.height);
    } else {
      ctx.fillStyle = '#1a1a22';
    }
    ctx.fillRect(0, 0, W, H);

    const wedge = (Math.PI * 2) / segments;

    const srcCx = src.width * parseFloat(elCx.value);
    const srcCy = src.height * parseFloat(elCy.value);

    for (let i = 0; i < segments; i++) {
      ctx.save();

      ctx.translate(cx, cy);
      ctx.rotate(rot + i * wedge);

      if (mirror && (i % 2 === 1)) {
        ctx.scale(-1, 1);
      }

      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, radius, -wedge / 2, wedge / 2);
      ctx.closePath();
      ctx.clip();

      ctx.scale(zoom, zoom);
      ctx.drawImage(src, -srcCx, -srcCy);

      ctx.restore();
    }

    rafId = requestAnimationFrame(render);
  }

  btnStart.addEventListener('click', startCamera);
  btnStop.addEventListener('click', stopCamera);
  btnReset.addEventListener('click', () => { resetControls(); if (stream) startCamera(); });

  [elFacing, elCamW, elCamH].forEach(el => {
    el.addEventListener('change', () => { if (stream) startCamera(); });
  });

  elSegments.addEventListener('change', () => {
    const v = Math.max(3, Math.min(64, parseInt(elSegments.value, 10) || 12));
    elSegments.value = v;
  });

  if (!navigator.mediaDevices?.getUserMedia) {
    alert("Your browser doesn't support getUserMedia.");
  }
})();
</script>
</body>
</html>
